{".gitignore":{"body":[],"description":".gitignore","prefix":".gitignore"},"art_points":{"body":["#define MAX 100000","","vector<int> G[MAX];","int N;","bool visited[MAX];","int prenum[MAX], parent[MAX], lowest[MAX], timer;","","void dfs(int current, int prev){","    prenum[current] = lowest[current] = timer;","    timer++;","","    visited[current] = true;","","    int next;","","    for(int i=0; i<G[current].size(); i++){","        next = G[current][i];","        if(!visited[next]){","            parent[next] = current;","","            dfs(next, current);","","            lowest[current] = min(lowest[current], lowest[next]);","        } else if (next != prev){","            lowest[current] = min(lowest[current], prenum[next]);","        }","    }","}","","void art_points(){","    for(int i=0; i<N; i++) visited[i] = false;","    timer = 1;","    dfs(0, -1);","","    set<int> ap;","    int np = 0;","    for(int i=1; i<N; i++){","        int p = parent[i];","        if(p==0) np++;","        else if (prenum[p] <= lowest[i]) ap.insert(p);","    }","    if(np>1) ap.insert(0);","    for(set<int>::iterator it = ap.begin(); it != ap.end(); it++)","        cout << *it << endl;","}"],"description":"art_points","prefix":"art_points"},"bellman_ford":{"body":["const int MAX_E = 2010;","const int MAX_V = 1010;","","#define INF (1 << 29)","","// 頂点と頂点を結ぶ辺についての構造体","struct edge { int from, to, cost; };","","edge es[MAX_E]; // 辺","","int d[MAX_V];","int V, E;","","//\tベルマンフォード（単一始点最短経路（Negative Edges))","// 負の閉路が存在したら true を返す","bool bellman_ford(int s) {","\tint cnt = 0;","\t// 最短距離の初期化","\tfor (int i = 0; i<V; i++) d[i] = INF;","\t// 頂点 s への最短距離は0","\td[s] = 0;","\twhile (true) {","\t\tcnt++;","\t\tbool update = false;","\t\t// すべての辺に対して","\t\tfor (int i = 0; i < E; i++) {","\t\t\tedge e = es[i];","\t\t\t// この時点での e.to へ行くコストより e.from を経由して行く方がコストが小さいとき d[e.to] を更新する","\t\t\tif (d[e.from] != INF && d[e.to] > d[e.from] + e.cost) {","\t\t\t\td[e.to] = d[e.from] + e.cost;","\t\t\t\t// V回目のループで更新が行われた場合、負の閉路が存在する","\t\t\t\tif(cnt == V) return true;","\t\t\t\tupdate = true;","\t\t\t}","\t\t}","\t\t// 更新がなければ終了","\t\tif (!update) break;","\t}","\treturn false;","}"],"description":"bellman_ford","prefix":"bellman_ford"},"binary_indexed_tree":{"body":["int N;","// bit[1]からbit[N]までを使用","int bit[1000010];","","","// v[a] += w  O(logN)","void add(int a, int w) {","\t// x & -x は x の最も下に立っているビットで、bit[x]が管理する区間の長さ.","\t// 次に更新すべき区間は、番号に区間の長さを足すと求まる.","\tfor (int x = a; x <= N; x += x & -x) bit[x] += w;","}","","// v[1]+...+v[a]  O(logN)","int sum(int a) {","\tint ret = 0;","\t// 次に足すべき区間は、番号から区間の長さを引くと求まる.","\tfor (int x = a; x > 0; x -= x & -x) ret += bit[x];","\treturn ret;","}"],"description":"binary_indexed_tree","prefix":"binary_indexed_tree"},"binary_search_meguru":{"body":["// index が条件を満たすかどうか","bool isOK(int index, int key){","    if(a[index] < key) return true;","    else return false;","}","","// 汎用的な二分探索のテンプレ","int binary_search(int key){","    int ng = (int)a.size();","    int ok = -1;","","    // ここは変える必要なし","    while(abs(ok-ng) > 1){","        int mid = (ok+ng) / 2;","","        if(isOK(mid,key)) ok = mid;","        else ng = mid;","    }","    return ok;","}"],"description":"binary_search_meguru","prefix":"binary_search_meguru"},"bipartite_graph":{"body":["const int MAX_V = 10000;","","vector<int> G[MAX_V];","int V, E;","int color[MAX_V];","","bool dfs(int v, int c){","    color[v] = c; // 頂点vをcで塗る","    for(int i=0; i<G[v].size(); i++){","        // 隣接している頂点が同じ色ならfalse","        if(color[G[v][i]] == c) return false;","        // 隣接している頂点がまだ塗られていないなら-cで塗る","        if(color[G[v][i]] == 0 && !dfs(G[v][i], -c)) return false;","    }","    // 全ての頂点を塗れたらtrue","    return true;","}"],"description":"bipartite_graph","prefix":"bipartite_graph"},"comb":{"body":["const int MAX = 510000;","const int MOD = (int)1e9+7;","","int fac[MAX], finv[MAX], inv[MAX]; // a!(fac[a]), (a!)^{-1}(finv[a]), a^{-1}(inv[a])","","// テーブルを作る前処理","void comb_init(){","    fac[0] = fac[1] = 1;","    finv[0] = finv[1] = 1;","    inv[1] = 1;","    for(int i=2; i<MAX; i++){","        fac[i] = fac[i-1] * i % MOD;","        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;","        finv[i] = finv[i-1] * inv[i] % MOD;","    }","}","","int comb(int n, int k){","    if(n < k) return 0;","    if(n < 0 || k < 0) return 0;","    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD;","}","","int main() {","    // 前処理","    comb_init();","","    // 計算例","    cout << comb(4, 2) << endl;","}"],"description":"comb","prefix":"comb"},"compress_1d":{"body":["vector<int> compress(vector<int> a) {","\tvector<int> b = a, res;","\tsort(b.begin(), b.end());","\tb.erase(unique(b.begin(), b.end()), b.end());","\tfor (int x : a) {","\t\tint tmp = lower_bound(b.begin(), b.end(), x) - b.begin();","\t\tres.push_back(tmp);","\t}","","\treturn res;","}"],"description":"compress_1d","prefix":"compress_1d"},"dijkstra":{"body":["struct edge { int to, cost; };","typedef pair<int, int> P;   // firstは最短距離、secondは頂点の番号","","const int MAX_V = 1000, MAX_E = 1000;","","int V, E;","vector<edge> G[MAX_V];","int d[MAX_V];","","void dijkstra(int s) {","\t// greater<P>を指定することでfirstが小さい順に取り出せるようにする","\tpriority_queue<P, vector<P>, greater<P> > que;","\tfill(d, d + V, INF);","\t// 始点 s の距離は０","\td[s] = 0;","\tque.push(P(0, s));","","\twhile (!que.empty()) {","\t\t// PQ内にあるものの中で最も距離の短いものを取り出す","\t\tP p = que.top(); que.pop();","\t\tint v = p.second;","\t\tif (d[v] < p.first) continue;","\t\t// 頂点 v と隣接している頂点を調べる","\t\tfor (int i = 0; i<G[v].size(); i++) {","\t\t\tedge e = G[v][i];","\t\t\t// この時点での頂点 e.to への最短距離より頂点 v を経由して頂点 e.to に行く経路の方が短いとき最短距離を更新する","\t\t\tif (d[e.to] > d[v] + e.cost) {","\t\t\t\td[e.to] = d[v] + e.cost;","\t\t\t\tque.push(P(d[e.to], e.to));","\t\t\t}","\t\t}","\t}","}"],"description":"dijkstra","prefix":"dijkstra"},"divisor":{"body":["// 約数の列挙O(√n)","vector<int> divisor(int n){","    vector<int> res;","    for(int i=1; i*i<=n; i++){","        if(n%i==0){","            res.push_back(i);","            // n の約数が i の時、n/i も n の約数になる","            if(i!=n/i) res.push_back(n/i);","        }","    }","    return res;","}"],"description":"divisor","prefix":"divisor"},"ext_gcd":{"body":["int extgcd(int a, int b, int& x, int& y){","    int d = a;","    if(b != 0){","        // d は a と b の最大公約数","        d = extgcd(b, a%b, y, x);","        y -= (a / b) * x;","    } else {","        x = 1; y = 0;","    }","    return d;","}"],"description":"ext_gcd","prefix":"ext_gcd"},"floyd":{"body":["static const int MAX = 100;","static const long long INFTY = (1LL << 32);","","int n;","long long d[MAX][MAX];","","// ワーシャルフロイド（全点対間最短経路(動的計画法)）","void floyd() {","\tfor (int k = 0; k<n; k++) {","\t\tfor (int i = 0; i<n; i++) {","\t\t\tif (d[i][k] == INFTY) continue;","\t\t\tfor (int j = 0; j<n; j++) {","\t\t\t\tif (d[k][j] == INFTY) continue;","\t\t\t\t// 頂点 k を経由する場合としない場合の最小コストを求める","\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);","\t\t\t}","\t\t}","\t}","}"],"description":"floyd","prefix":"floyd"},"gcd":{"body":["int gcd(int a, int b){","    //cout << a <<\" \"<< b << endl;","    if(b==0) return a;","    return gcd(b, a%b);","}"],"description":"gcd","prefix":"gcd"},"get_path_dijkstra":{"body":["struct edge { int to, cost; };","typedef pair<int, int> P;   // firstは最短距離、secondは頂点の番号","","const int MAX_V=1000, MAX_E=1000;","","int V;","vector<edge> G[MAX_V];","int d[MAX_V];","","int Prev[MAX_V];","","void dijkstra(int s){","    // greater<P>を指定することでfirstが小さい順に取り出せるようにする","    priority_queue<P, vector<P>, greater<P> > que;","    fill(d,d+V,INF);","    fill(Prev,Prev+V,-1);","    d[s]=0;","    que.push(P(0,s));","","    while(!que.empty()){","        P p = que.top(); que.pop();","        int v=p.second;","        if(d[v] < p.first) continue;","        for(int i=0; i<G[v].size(); i++){","            edge e=G[v][i];","            if(d[e.to] > d[v]+e.cost){","                d[e.to] = d[v]+e.cost;","                que.push(P(d[e.to], e.to));","                Prev[e.to]=v;","            }","        }","    }","}","","// 頂点tへの最短路","vector<int> get_path(int t){","    vector<int> path;","    for(; t != -1; t=Prev[t]) path.push_back(t);  // tがsになるまでprev[t]を辿っていく","    // このままだとt->sの順になっているので逆順にする","    reverse(path.begin(),path.end());","    return path;","}"],"description":"get_path_dijkstra","prefix":"get_path_dijkstra"},"is_bracket":{"body":["/* 引数 s がBracket Sequence かどうかを返す O(s.length()) */","bool is_bracket(string s){","    // 括弧のそれぞれの数をカウント","    int cnt1=0, cnt2=0;","    for(int i=0; i<s.length(); i++){","        if(s[i]=='(') cnt1++;","        else cnt2++;","    }","    // スタックで部分的にBracketSequenceになっている場所を削除していく","    stack<char> st;","    for(int i=0; i<s.length(); i++){","        char ch = '0';","        if(!st.empty()) ch = st.top();","        if(s[i]==')'){","            if(ch=='('){","                cnt1--;","                cnt2--;","                st.pop();","            } else {","                st.push(s[i]);","            }","        } else {","            st.push(s[i]);","        }","    }","","    // 消されなかった括弧がある場合はfalse","    if(cnt1>0 || cnt2>0) return false;","    else return true;","}"],"description":"is_bracket","prefix":"is_bracket"},"is_prime":{"body":["// 素数判定O(√n)","bool is_prime(int n){","    for(int i=2; i*i<=n; i++){","        if(n%i==0) return false;","    }","    return n != 1;  // 1の場合は例外","}"],"description":"is_prime","prefix":"is_prime"},"kd_tree":{"body":["class Node{","public:","    int location;","    int p, l, r;","    Node(){}","};","","class Point{","public:","    int id, x, y;","    Point(){}","    Point(int id, int x, int y): id(id), x(x), y(y) {}","    bool operator < ( const Point &p) const {","        return id < p.id;","    }","","    void print() {","        printf(\"%d\\n\", id);","    }","};","","static const int MAX = 1000000;","static const int NIL = -1;","","int N;","Point P[MAX];","Node T[MAX];","int np;","","bool lessX(const Point &p1, const Point &p2) { return p1.x < p2.x; }","bool lessY(const Point &p1, const Point &p2) { return p1.y < p2.y; }","","int makeKDTree(int l, int r, int depth){","    if(!(l<r)) return NIL;","    int mid = (l+r)/2;","    int t = np++;","    if(depth%2==0){","        sort(P+l, P+r, lessX);","    } else {","        sort(P+l, P+r, lessY);","    }","    T[t].location = mid;","    T[t].l = makeKDTree(l, mid, depth+1);","    T[t].r = makeKDTree(mid+1, r, depth+1);","","    return t;","}","","void find(int v, int sx, int tx, int sy, int ty, int depth, vector<Point> &ans){","    int x = P[T[v].location].x;","    int y = P[T[v].location].y;","","    if(sx<=x && x<=tx && sy<=y && y<=ty){","        ans.push_back(P[T[v].location]);","    }","","    if(depth%2==0){","        if(T[v].l != NIL){","            if(sx<=x) find(T[v].l, sx, tx, sy, ty, depth+1, ans);","        }","        if(T[v].r != NIL){","            if(x<=tx) find(T[v].r, sx, tx, sy, ty, depth+1, ans);","        }","    } else {","        if(T[v].l != NIL){","            if(sy <= y) find(T[v].l, sx, tx, sy, ty, depth+1, ans);","        }","        if(T[v].r != NIL){","            if(y<=ty) find(T[v].r, sx, tx, sy, ty, depth+1, ans);","        }","    }","}"],"description":"kd_tree","prefix":"kd_tree"},"kruskal":{"body":["class DisjointSet {","public:","\tvector<int> rank, p;","","\tDisjointSet() {}","\tDisjointSet(int size) {","\t\trank.resize(size, 0);","\t\tp.resize(size, 0);","\t\tfor (int i = 0; i<size; i++) makeSet(i);","\t}","","\tvoid makeSet(int x) {","\t\tp[x] = x;","\t\trank[x] = 0;","\t}","","\tbool same(int x, int y) {","\t\treturn findSet(x) == findSet(y);","\t}","","\tvoid unite(int x, int y) {","\t\tlink(findSet(x), findSet(y));","\t}","","\tvoid link(int x, int y) {","\t\tif (rank[x] > rank[y]) {","\t\t\tp[y] = x;","\t\t}","\t\telse {","\t\t\tp[x] = y;","\t\t\tif (rank[x] == rank[y]) {","\t\t\t\trank[y]++;","\t\t\t}","\t\t}","\t}","","\tint findSet(int x) {","\t\tif (x != p[x]) {","\t\t\tp[x] = findSet(p[x]);","\t\t}","\t\treturn p[x];","\t}","};","","class Edge {","public:","\tint source, target, cost;","\tEdge(int source = 0, int target = 0, int cost = 0) :","\t\tsource(source), target(target), cost(cost) {}","\tbool operator < (const Edge &e) const {","\t\treturn cost < e.cost;","\t}","};","","int kruskal(int N, vector<Edge> edges) {","\tint totalCost = 0;","\t// edgesを昇順でソート","\tsort(edges.begin(), edges.end());","","\tDisjointSet dset = DisjointSet(N + 1);","","\tfor (int i = 0; i<N; i++) dset.makeSet(i);","","\tfor (int i = 0; i<edges.size(); i++) {","\t\tEdge e = edges[i];","\t\tif (!dset.same(e.source, e.target)) {","\t\t\ttotalCost += e.cost;","\t\t\tdset.unite(e.source, e.target);","\t\t}","\t}","\treturn totalCost;","}"],"description":"kruskal","prefix":"kruskal"},"mod_pow":{"body":["const int MOD = 1000000007;","","/* x^nを高速に求める */","int mod_pow(int x, int n) {","\tint res = 1;","\twhile (n > 0) {","\t\tif (n & 1) res = res*x%MOD;  // 最下位ビットが立ってる時にx^(2^i)を掛ける","\t\tx = x*x%MOD;              // xを順次二乗していく","\t\tn >>= 1;    // 右ビットシフト","\t}","\treturn res;","}"],"description":"mod_pow","prefix":"mod_pow"},"newton":{"body":["vector<double> a(10);","","double f(double x, int dm){","    double res;","    int cntx = dm;","    for(int i=0; i<dm; i++){","        double b = a[i];","        for(int j=0; j<cntx; j++) b *= x;","        cntx--;","        res += b;","    }","    return res;","}","","double fdash(double x, int dm){","    double res;","    int cntx = dm-1, k=dm;","    for(int i=0; i<dm-1; i++){","        double b = a[i]*k;","        for(int j=0; j<dm-1; j++) b *= x;","        cntx--;","        k--;","        res += b;","    }","    return res;","}","","double newton(double x0, double eps, int dm){","    while(1){","        printf(\"%.10f\\n\", x0);","        double x1 = x0 - f(x0, dm) / fdash(x0, dm);","        if(abs(x1-x0)<eps) return x1;","        x0 = x1;","    }","}"],"description":"newton","prefix":"newton"},"next_combination":{"body":["int next_combination(int sub){","    int x = sub & -sub, y = sub + x;","    return (((sub & ~y) / x) >> 1) | y;","}","","int main() {","    int n=5;","    int k=3;","","    int bit = (1<<k)-1;","    for(;bit < (1<<n); bit = next_combination(bit)){","        vector<int> S;","        for(int i=0; i<n; i++){","            if(bit & (1<<i)){","                S.push_back(i);","            }","        }","","        cout << bit <<\":\";","        for(int i=0; i<(int)S.size(); i++){","            cout <<\" \"<< S[i];","        }","        cout << endl;","    }","}"],"description":"next_combination","prefix":"next_combination"},"pascal_triangle":{"body":["int comb[3010][1510];","","void calc_comb(int n, int k) {","\tcomb[0][0] = 0;","\tcomb[1][0] = comb[1][1] = 1;","","\tfor (int i = 2; i < n; i++) {","\t\tfor (int j = 0; j < k; j++) {","\t\t\tif(i<j) continue;","\t\t\tif(j==0 || j==i) comb[i][j] = 1;","\t\t\telse {","\t\t\t\tif(comb[i-1][j]==-1 || comb[i-1][j-1]==-1) comb[i][j]=-1;","\t\t\t\telse comb[i][j] = comb[i - 1][j] + comb[i - 1][j - 1];","\t\t\t}","\t\t\tif(comb[i][j] > (int)1e16) comb[i][j]=-1;","\t\t}","\t}","}"],"description":"pascal_triangle","prefix":"pascal_triangle"},"prim":{"body":["const int MAX_V = 1000;","","int cost[MAX_V][MAX_V];\t// グラフの隣接行列","int mincost[MAX_V];\t// MSTからMSTでないの頂点へ行く最小コスト","bool used[MAX_V];\t// MSTの属しているかどうか","int V;\t// 頂点数","","int prim() {","\tfor (int i = 0; i<V; i++) {","\t\tmincost[i] = INF;","\t\tused[i] = false;","\t}","\tmincost[0] = 0;","\tint res = 0;\t// MSTのコストの総和","","\twhile (true) {","\t\tint v = -1;","\t\t// MSTに属さない頂点のうちMSTからの辺のコストが最小になる頂点を探す","\t\tfor (int u = 0; u<V; u++) {","\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;","\t\t}","","\t\tif (v == -1) break;","\t\tused[v] = true;     // 頂点 v をMSTに追加","\t\tres += mincost[v];  // 頂点 v が確定したので辺のコストを加える","","\t\t// 頂点 v に隣接している頂点を調べ、その時点での頂点 u への最小コストを更新する","\t\tfor (int u = 0; u<V; u++) {","\t\t\tmincost[u] = min(mincost[u], cost[v][u]);","\t\t}","\t}","\treturn res;","}"],"description":"prim","prefix":"prim"},"prime_factor":{"body":["// 素因数分解O(√n)","map<int, int> prime_factor(int n){","    map<int, int> res;","    for(int i=2; i*i<=n; i++){","        while(n%i==0){","            ++res[i];","            n /= i;","        }","    }","    if(n!=1) res[n] = 1;","    return res;","}"],"description":"prime_factor","prefix":"prime_factor"},"prime_library":{"body":[],"description":"prime_library","prefix":"prime_library"},"rasen_prim":{"body":["static const int MAX = 100;","static const int INFTY = (1<<21);","static const int WHITE = 0;","static const int GRAY = 1;","static const int BLACK = 2;","","int n, M[MAX][MAX];\t// n:頂点数, M[][]:隣接行列","","// primのアルゴリズム","int prim() {","\tint u, minv;","\t// d[n]:d[v]にTに属する頂点とV-Tに属する頂点をつなぐ辺の中で、重みが最小の辺の重みを記録","\t// p[n]:p[v]にMSTにおける頂点vの親を記録する","\tint d[MAX], p[MAX], color[MAX];","","\t// 初期化","\tfor (int i = 0; i < n; i++) {","\t\td[i] = INFTY;","\t\tp[i] = -1;","\t\tcolor[i] = WHITE;","\t}","","\td[0] = 0;","","\twhile (1) {","\t\tminv = INFTY;","\t\tu = -1;","\t\t// VとV-Tをつなぐ辺のうち最小の辺の重みとなる頂点 u を探す","\t\tfor (int i = 0; i < n; i++) {","\t\t\tif (minv > d[i] && color[i] != BLACK) {","\t\t\t\tu = i;","\t\t\t\tminv = d[i];","\t\t\t}","\t\t}","\t\tif(u == -1) break;","\t\t// 頂点 u をMSTに追加","\t\tcolor[u] = BLACK;","","\t\tfor (int v = 0; v < n; v++) {","\t\t\tif (color[v] != BLACK && M[u][v] != INFTY) {","\t\t\t\tif (d[v] > M[u][v]) {","\t\t\t\t\t// この時点での頂点 v への最小コストを更新する。またその親を u とする","\t\t\t\t\td[v] = M[u][v];","\t\t\t\t\tp[v] = u;","\t\t\t\t\tcolor[v] = GRAY;","\t\t\t\t}","\t\t\t}","\t\t}","\t}","\t// 最小全域木の総和を計算　最適な辺は頂点 i と 頂点 p[i](頂点iの親) を結ぶ辺となる。","\tint sum=0;","\tfor (int i = 0; i < n; i++) {","\t\tif(p[i] != -1) sum += M[i][p[i]];","\t}","","\treturn sum;","}"],"description":"rasen_prim","prefix":"rasen_prim"},"segment_sieve":{"body":["#define MAX_L (1000000)","#define MAX_SQRT_B (1000000)","","bool is_prime[MAX_L];","bool is_prime_small[MAX_SQRT_B];","","// [a,b)の整数に対して篩を行う。is_prime[i-a]=true ⇔ iが素数","void segment_sieve(int a, int b){","    for(int i=0; i * i < b; i++) is_prime_small[i] = true;","    for(int i=0; i < b-a; i++) is_prime[i] = true;","","    for(int i=2; i * i < b; i++){","        if(is_prime_small[i]){","            // [2,√b)の表から素数が得られるたびに、その素数の倍数を[a,b)から除く","            for(int j=2*i; j * j <b; j+=i) is_prime_small[j]=false; // [2,√b)の篩","            for(int j=max(2LL, (a+i-1)/i) * i; j<b; j+=i) is_prime[j-a]=false; // [a,b)の篩","        }","    }","}"],"description":"segment_sieve","prefix":"segment_sieve"},"segment_tree_rmq":{"body":["const int MAX_N = 1 << 17;","","int n, dat[2 * MAX_N - 1];","","// 初期化","void init(int n_) {","\t// 簡単のために、要素数を２のべき乗にする","\tn = 1;","\twhile (n < n_) n *= 2;","","\tfor (int i = 0; i<(2 * n - 1); i++) dat[i] = INT_MAX;","}","","// k 番目の値(0-indexed)を a に変更","void update(int k, int a) {","\t// 葉の節点","\tk += n - 1;","\tdat[k] = a;","","\t// 登りながら更新","\twhile (k > 0) {","\t\t// 親の節点は (k-1)/2","\t\tk = (k - 1) / 2;","\t\t// 2つの子の最小値を求める","\t\tdat[k] = min(dat[k * 2 + 1], dat[k * 2 + 2]);","\t}","}","","// [a,b)の最小値を求める. k:節点の番号. l,r:その節点が[l,r)に対応づいていることを表す.","// find(a,b,0,0,n)で呼ぶ","int find(int a, int b, int k, int l, int r) {","\t// [a,b)と[l,r)が交差しなければ、INT_MAX","\tif (r <= a || b <= l) return INT_MAX;","","\t// [a,b)が[l,r)を完全に含んでいれば、この節点の値","\tif (a <= l && r <= b) return dat[k];","\telse {","\t\t// そうでなければ、２つの子の最小値","\t\tint vl = find(a, b, k * 2 + 1, l, (l + r) / 2);\t\t// 左の子","\t\tint vr = find(a, b, k * 2 + 2, (l + r) / 2, r);\t\t// 右の子","\t\treturn min(vl, vr);","\t}","}"],"description":"segment_tree_rmq","prefix":"segment_tree_rmq"},"segment_tree_ruq":{"body":["const int MAX_N = 1 << 18;","typedef pair<int,int> P;","","int n;","// Segment-Tree first:最後に変更した番号, second:その区間の値","P dat[2*MAX_N-1];","","// 2のべき乗で初期化","void init(int n_) {","\tn=1;","\twhile(n < n_) n*=2;","\tfor(int i=0; i<2*n-1; i++) dat[i].first = -1, dat[i].second = INT_MAX;","}","","// k 番目の値(0-indexed)を求める","// (葉の値がk番目の値とは限らない. 親の区間で最後に更新された場所を探す)","int find(int k) {","\t// 葉の節点","\tk += n-1;","\tP p=dat[k];","","\t// 登りながら求める","\twhile (k > 0) {","\t\t// kの親を求める","\t\tk = (k-1)/2;","\t\t// firstの最大値を求める -> 最後に変更された場所","\t\tp = max(p, dat[k]);","\t}","\treturn p.second;","}","","// [a,b)を x に変更する. k:節点, [l,r)","void update(int a, int b, int k, P p, int l, int r) {","\t// 範囲外ならreturn","\tif(r <= a || b <= l) return;","\t// [l,r)が[a,b)の区間に完全に含まれるならその節点を p をする","\tif (a <= l && r <= b) {","\t\tdat[k] = p;","\t}","\t// それ以外なら、２つの子に移る","\telse {","\t\tupdate(a,b,k*2+1,p,l,(l+r)/2);","\t\tupdate(a,b,k*2+2,p,(l+r)/2,r);","\t}","}"],"description":"segment_tree_ruq","prefix":"segment_tree_ruq"},"sieve":{"body":["#define MAX_N (1000000)","int prime[MAX_N];           // i番目の素数","bool is_prime[MAX_N+1];     // is_prime[i]がtrueならiは素数","","// n 以下の素数の数を返す","int sieve(int n){","    int p=0;","    // 初期化 全てを素数と仮定する","    for(int i=0; i<=n; i++) is_prime[i] = true;","    // 0と1は排除","    is_prime[0] = is_prime[1] = false;","","    for(int i=2; i<=n; i++){","        if(is_prime[i]){    // iが素数の時","            prime[p++] = i; // p番目をiとして確定させる","            //cout << prime[p-1] << endl;","            // 表からiの倍数を取り除く","            for(int j=2*i; j<=n; j+=i) is_prime[j] = false;","        }","    }","    return p;","}"],"description":"sieve","prefix":"sieve"},"starry_sky":{"body":["static const int MAX_N = 1 << 17;","","struct StarrySky {","\t// datm[]:区間の最大値を管理する, data[]:加算された区間を管理する","\tint datm[2 * MAX_N], data[2 * MAX_N], n;","\tStarrySky() {}","\tStarrySky(int n_) { init(n_); }","","\t// 初期化 2のべき乗に設定","\tvoid init(int n_) {","\t\tn = 1;","\t\twhile (n<n_) n *= 2;","\t\tfor (int i = 0; i<n * 2; i++) datm[i] = data[i] = 0;","\t}","","\t// [a,b), x, k:節点, [l,r)","\tvoid add(int a, int b, int x, int k, int l, int r) {","\t\t// 区間外","\t\tif (r <= a || b <= l) return;","","\t\t// [a,b)が[l,r)を完全に含む場合","\t\tif (a <= l && r <= b) {","\t\t\t// 区間に x を足す","\t\t\tdata[k] += x;","\t\t}","\t\telse {","\t\t\t// 左の子の区間に移動","\t\t\tadd(a, b, x, k * 2 + 1, l, (l + r) / 2);","\t\t\t// 右の子の区間に移動","\t\t\tadd(a, b, x, k * 2 + 2, (l + r) / 2, r);","\t\t\t// 親の区間の最大値は、子の区間の最大値 + 自分に一様に加算されている値","\t\t\tdatm[k] = max(datm[k * 2 + 1] + data[k * 2 + 1], datm[k * 2 + 2] + data[k * 2 + 2]);","\t\t}","\t}","","\t// 区間[a,b)の最大値を取得する","\tint get(int a, int b, int k, int l, int r) {","\t\t// 区間外","\t\tif (r <= a || b <= l) return 0;","","\t\t// 区間に完全に含まれる場合","\t\tif (a <= l && r <= b) return datm[k] + data[k];","","\t\t// 子を調べる","\t\tint vl = get(a, b, k * 2 + 1, l, (l + r) / 2);","\t\tint vr = get(a, b, k * 2 + 2, (l + r) / 2, r);","","\t\t// 親の区間の最大値は、この区間の最大値 + 自分に一様に加算されている値","\t\treturn max(vl, vr) + data[k];","\t}","","\tvoid add(int a, int b, int x) {","\t\tadd(a, b, x, 0, 0, n);","\t}","","\tint get(int a, int b) {","\t\treturn get(a, b, 0, 0, n);","\t}","","};"],"description":"starry_sky","prefix":"starry_sky"},"topological_sort_bfs":{"body":["static const int MAX = 100000;","static const int INF = (1 << 29);","","vector<int> G[MAX];\t// 隣接リスト","list<int> out;\t// トポロジカルソートした結果を格納するリスト","bool V[MAX];\t// その頂点が完了したかどうか","int N;\t\t\t// 頂点数","int indeg[MAX];\t// その頂点の入次数","","// 幅優先探索","void bfs(int s) {","\tqueue<int> q;","\tq.push(s);","\tV[s] = true;","\twhile (!q.empty()) {","\t\tint u = q.front(); q.pop();","\t\tout.push_back(u);","\t\t// u と隣接している頂点を調べる","\t\tfor (int i = 0; i < G[u].size(); i++) {","\t\t\t// 頂点 u は完了している頂点なので、頂点 u と頂点 v をつなぐ辺を削除して考える -> 入次数をデクリメント","\t\t\tint v = G[u][i];","\t\t\tindeg[v]--;","\t\t\t// 入次数が０で完了していない頂点をキューにプッシュ","\t\t\tif (indeg[v] == 0 && !V[v]) {","\t\t\t\tV[v] = true;","\t\t\t\tq.push(v);","\t\t\t}","\t\t}","\t}","}","","void tsort() {","\t// 入次数の初期化","\tfor (int i = 0; i < N; i++) {","\t\tindeg[i] = 0;","\t}","","\t// 入次数の設定","\tfor (int u = 0; u < N; u++) {","\t\tfor (int i = 0; i < G[u].size(); i++) {","\t\t\t// 頂点 u から頂点 v へ辺が繋がっているので入次数をインクリメント","\t\t\tint v = G[u][i];","\t\t\tindeg[v]++;","\t\t}","\t}","","\tfor (int u = 0; u < N; u++) {","\t\t// 入次数が０で完了していない頂点を幅優先探索","\t\tif (indeg[u] == 0 && !V[u]) {","\t\t\tbfs(u);","\t\t}","\t}","","\t// トポロジカルソートした結果を表示","\tfor (list<int>::iterator it = out.begin(); it != out.end(); it++) {","\t\tcout << *it << endl;","\t}","}"],"description":"topological_sort_bfs","prefix":"topological_sort_bfs"},"topological_sort_dfs":{"body":["static const int MAX = 100000;","","vector<int> G[MAX];\t// 隣接リスト","list<int> out;\t// トポロジカルソートした結果を格納するリスト","bool V[MAX];\t// その頂点が完了したかどうか","int N;\t\t\t// 頂点数","int indeg[MAX];\t// その頂点の入次数","","// 最後に行うものから順にリストに追加していく深さ優先探索","void dfs(int u) {","\tV[u] = true;","\tfor (int i = 0; i < G[u].size(); i++) {","\t\tint v = G[u][i];","\t\t// 完了していない頂点を深さ優先探索","\t\tif(!V[v]) dfs(v);","\t}","\tout.push_front(u);","}"],"description":"topological_sort_dfs","prefix":"topological_sort_dfs"},"unionfind":{"body":["class DisjointSet{","public:","    vector<int> rank, p;","","    DisjointSet() {}","    DisjointSet(int size){","        rank.resize(size, 0);","        p.resize(size, 0);","        for(int i=0; i<size; i++) makeSet(i);","    }","","    void makeSet(int x){","        p[x] = x;","        rank[x] = 0;","    }","","    bool same(int x, int y){","        return findSet(x) == findSet(y);","    }","","    void unite(int x, int y){","        link(findSet(x), findSet(y));","    }","","    void link(int x, int y){","        if(rank[x] > rank[y]){","            p[y] = x;","        } else {","            p[x] = y;","            if(rank[x] == rank[y]){","                rank[y]++;","            }","        }","    }","","    int findSet(int x){","        if(x != p[x]){","            p[x] = findSet(p[x]);","        }","        return p[x];","    }","};"],"description":"unionfind","prefix":"unionfind"},"unionfind_by_size":{"body":["class  DisjointSet {","    public:","        vector<int> p, siz;","","        DisjointSet() {}","        DisjointSet(int size) {","            p.resize(size, 0);","            siz.resize(size, 1);","            for(int i=0; i<size; i++) makeSet(i);","        }","","        void makeSet(int x){","            p[x] = x;","        }","","        bool same(int x, int y){","            return findSet(x) == findSet(y);","        }","","        int size(int x){","            return siz[findSet(x)];","        }","","        void unite(int x, int y){","            x = findSet(x);","            y = findSet(y);","            if(x == y) return;","            if(siz[x] < siz[y]) swap(x, y);","            siz[x] += siz[y];","            p[y] = x;","        }","","        int findSet(int x){","            if(x != p[x]){","                p[x] = findSet(p[x]);","            }","            return p[x];","        }","};"],"description":"unionfind_by_size","prefix":"unionfind_by_size"},"unionfind_weighted":{"body":["class WeightedUnionFind {","public:","    vector<int> par;","    vector<int> rank;","    vector<int> diff_weight;","","    WeightedUnionFind() {}","    WeightedUnionFind(int size, int weight){","        rank.resize(size,0);","        par.resize(size,0);","        diff_weight.resize(size,0);","        for(int i=0; i<size; i++) makeSet(i,weight);","    }","","    void makeSet(int x, int weight){","        par[x] = x;","        rank[x] = 0;","        diff_weight[x] = weight;","    }","","    bool same(int x, int y){","        return findSet(x) == findSet(y);","    }","","    bool relate(int x, int y, int w){","        w += weight(x); w -= weight(y);","        x = findSet(x); y = findSet(y);","","        if(x == y) return false;","        if(rank[x] < rank[y]){","            swap(x,y);","            w = -w;","        }","        if(rank[x] == rank[y]) rank[x]++;","        par[y] = x;","        diff_weight[y] = w;","        return true;","    }","","    int diff(int x, int y){","        return weight(y) - weight(x);","    }","","    int weight(int x){","        findSet(x);","        return diff_weight[x];","    }","","    int findSet(int x){","        if(par[x] == x){","            return x;","        }","        else {","            int r = findSet(par[x]);","            diff_weight[x] += diff_weight[par[x]];","            return par[x] = r;","        }","    }","","};"],"description":"unionfind_weighted","prefix":"unionfind_weighted"}}