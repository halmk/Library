{"dijkstra":{"body":["struct edge { int to, cost; };","typedef pair<int, int> P;   // firstは最短距離、secondは頂点の番号","","const int MAX_V = 1000, MAX_E = 1000;","","int V, E;","vector<edge> G[MAX_V];","int d[MAX_V];","","void dijkstra(int s) {","\t// greater<P>を指定することでfirstが小さい順に取り出せるようにする","\tpriority_queue<P, vector<P>, greater<P> > que;","\tfill(d, d + V, INF);","\t// 始点 s の距離は０","\td[s] = 0;","\tque.push(P(0, s));","","\twhile (!que.empty()) {","\t\t// PQ内にあるものの中で最も距離の短いものを取り出す","\t\tP p = que.top(); que.pop();","\t\tint v = p.second;","\t\tif (d[v] < p.first) continue;","\t\t// 頂点 v と隣接している頂点を調べる","\t\tfor (int i = 0; i<G[v].size(); i++) {","\t\t\tedge e = G[v][i];","\t\t\t// この時点での頂点 e.to への最短距離より頂点 v を経由して頂点 e.to に行く経路の方が短いとき最短距離を更新する","\t\t\tif (d[e.to] > d[v] + e.cost) {","\t\t\t\td[e.to] = d[v] + e.cost;","\t\t\t\tque.push(P(d[e.to], e.to));","\t\t\t}","\t\t}","\t}","}"],"description":"dijkstra","prefix":"dijkstra"}}